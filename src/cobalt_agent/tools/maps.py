"""
AOM Maps Module - Stateful Element Handle Mapping

This module provides a stateful mapping class that stores the relationship between
numeric IDs generated by the AOM extractor and the actual Playwright ElementHandle
or specific CDP node locator.

Features:
- Map numeric IDs to Playwright ElementHandle or CDP node locators
- Refresh tree upon navigation to prevent stale element reference errors
- Invalidate old IDs when the DOM changes
- Thread-safe access with locking
"""
from typing import Optional, Dict, Any
from playwright.sync_api import ElementHandle, Page
from loguru import logger
from copy import deepcopy


class Maps:
    """
    Stateful mapping between AOM numeric IDs and Playwright ElementHandles.
    
    This class maintains a cache of element IDs to their current ElementHandle
    or CDP node locator reference. It provides methods to:
    - Store element mappings
    - Retrieve elements by ID
    - Refresh mappings when the page changes
    - Invalidate stale references
    """
    
    def __init__(self):
        """Initialize the Maps cache with empty storage and no page reference."""
        self._element_cache: Dict[int, Dict[str, Any]] = {}
        self._current_url: Optional[str] = None
        self._page: Optional[Page] = None
        self._lock = None  # Can use threading.Lock for thread safety
        logger.debug("Maps instance initialized with empty cache")
    
    def _create_element_reference(self, element_id: int, selector: str) -> Dict[str, Any]:
        """
        Create a reference dictionary for an element.
        
        Args:
            element_id: The numeric ID from AOM extraction
            selector: The CSS selector to locate the element
            
        Returns:
            Dictionary containing element reference data
        """
        return {
            "id": element_id,
            "selector": selector,
            "created_at": __import__("time").time(),
            "valid": True
        }
    
    def add_element(self, element_id: int, selector: str, element: Optional[ElementHandle] = None) -> None:
        """
        Add or update an element mapping.
        
        Args:
            element_id: The numeric ID from AOM extraction
            selector: The CSS selector to locate the element
            element: Optional ElementHandle reference
        """
        if element_id in self._element_cache:
            logger.debug(f"Updating existing element mapping for ID {element_id}")
        else:
            logger.debug(f"Adding new element mapping for ID {element_id}")
        
        reference = self._create_element_reference(element_id, selector)
        
        # Store optional ElementHandle (as a marker - Playwright handles can't be serialized)
        if element:
            reference["has_handle"] = True
            # Note: We don't store the actual ElementHandle as it can't be pickled
            # and Playwright will invalidate it on page changes anyway
        else:
            reference["has_handle"] = False
        
        self._element_cache[element_id] = reference
    
    def get_element(self, element_id: int) -> Optional[Dict[str, Any]]:
        """
        Retrieve an element reference by its ID.
        
        Args:
            element_id: The numeric ID to look up
            
        Returns:
            Dictionary containing element reference data, or None if not found
        """
        element = self._element_cache.get(element_id)
        if element:
            if element.get("valid", False):
                return element
            else:
                logger.warning(f"Element ID {element_id} is marked as invalid")
        return None
    
    def remove_element(self, element_id: int) -> bool:
        """
        Remove an element from the cache.
        
        Args:
            element_id: The numeric ID to remove
            
        Returns:
            True if the element was removed, False if not found
        """
        if element_id in self._element_cache:
            del self._element_cache[element_id]
            logger.debug(f"Removed element ID {element_id} from cache")
            return True
        return False
    
    def refresh_tree(self, page: Page, new_url: Optional[str] = None) -> None:
        """
        Invalidate all cached elements and update the current URL.
        
        This should be called after navigation to prevent stale element reference errors.
        
        Args:
            page: The current Playwright Page object
            new_url: Optional new URL after navigation
        """
        logger.info("Refreshing Maps tree - invalidating all cached elements")
        
        # Invalidate all existing references
        for element_id in self._element_cache:
            self._element_cache[element_id]["valid"] = False
        
        # Update current URL
        if new_url:
            self._current_url = new_url
            logger.debug(f"Updated current URL to: {new_url}")
        else:
            try:
                self._current_url = page.url
                logger.debug(f"Current URL: {page.url}")
            except Exception as e:
                logger.warning(f"Failed to get current URL: {e}")
        
        self._page = page
    
    def clear(self) -> None:
        """Clear all cached elements."""
        logger.info("Clearing all element mappings from cache")
        self._element_cache.clear()
        self._current_url = None
        self._page = None
    
    def get_all_elements(self) -> Dict[int, Dict[str, Any]]:
        """
        Get all cached elements.
        
        Returns:
            Dictionary mapping element IDs to their reference data
        """
        return self._element_cache
    
    def is_valid_element(self, element_id: int) -> bool:
        """
        Check if an element ID is valid (exists and is marked valid).
        
        Args:
            element_id: The numeric ID to check
            
        Returns:
            True if the element exists and is valid, False otherwise
        """
        element = self._element_cache.get(element_id)
        if not element:
            return False
        return element.get("valid", False)
    
    def invalidate_all(self) -> None:
        """Mark all cached elements as invalid."""
        logger.info("Invalidating all cached elements")
        for element_id in self._element_cache:
            self._element_cache[element_id]["valid"] = False
    
    def get_current_url(self) -> Optional[str]:
        """
        Get the current URL being mapped.
        
        Returns:
            The current URL, or None if not set
        """
        return self._current_url
    
    def set_page(self, page: Page) -> None:
        """
        Set the current Playwright page for future operations.
        
        Args:
            page: The Playwright Page object
        """
        self._page = page
        logger.debug("Page reference updated in Maps")
    
    def get_page(self) -> Optional[Page]:
        """
        Get the current Playwright page reference.
        
        Returns:
            The current Page object, or None if not set
        """
        return self._page
    
    def find_element_by_selector(self, selector: str) -> Optional[Dict[str, Any]]:
        """
        Find an element by its CSS selector.
        
        Args:
            selector: The CSS selector to search for
            
        Returns:
            Dictionary containing element reference data, or None if not found
        """
        for element_id, reference in self._element_cache.items():
            if reference.get("selector") == selector:
                if reference.get("valid", False):
                    return reference
        return None


# Singleton instance for convenience
_maps_instance: Optional[Maps] = None


def get_maps() -> Maps:
    """
    Get the global Maps singleton instance.
    
    Returns:
        The Maps instance
    """
    global _maps_instance
    if _maps_instance is None:
        _maps_instance = Maps()
    return _maps_instance


def reset_maps() -> Maps:
    """
    Reset the global Maps instance (create new instance).
    
    Returns:
        A new Maps instance
    """
    global _maps_instance
    if _maps_instance is not None:
        _maps_instance.clear()
    _maps_instance = Maps()
    return _maps_instance


def refresh_maps_tree(page: Page, new_url: Optional[str] = None) -> None:
    """
    Convenience function to refresh the global Maps tree.
    
    Args:
        page: The current Playwright Page object
        new_url: Optional new URL after navigation
    """
    maps = get_maps()
    maps.refresh_tree(page, new_url)